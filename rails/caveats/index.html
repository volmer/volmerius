<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Caveats</title>
<meta name="description" content="
No design is perfect. The architecture proposed in this document provides a good
starting point for sustainable, long term development in Rails, but by no means
it gives answers to all possible cases and complications that could arise along
the way. It is crucial for developers to always keep in mind the principles of
object oriented design while adopting this architecture, such as keeping objects
small and simple, with thoughtful introduction of indirection when necessary.">
<meta name="author" content="Volmer Campos Soares">

<meta property="og:image" content="https://volmerius.com/images/volmer.jpg" />

<link rel="stylesheet" href="/css/main.css">

<link rel="icon" href="/images/volmer.ico" sizes="any">
<link rel="icon" href="/images/volmer.svg" type="image/svg+xml">

<script async src="https://www.googletagmanager.com/gtag/js?id=G-KJM1NP2BYC"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-KJM1NP2BYC');
</script>

<script>
  document.addEventListener('DOMContentLoaded', () => {
    // Get all "navbar-burger" elements
    const $navbarBurgers = Array.prototype.slice.call(
      document.querySelectorAll('.navbar-burger'), 0
    );

    // Add a click event on each of them
    $navbarBurgers.forEach( el => {
      el.addEventListener('click', () => {
        // Get the target from the "data-target" attribute
        const target = el.dataset.target;
        const $target = document.getElementById(target);

        // Toggle the "is-active" class on both the "navbar-burger" and the "navbar-menu"
        el.classList.toggle('is-active');
        $target.classList.toggle('is-active');
      });
    });
  });
</script>

  </head>

  <body>
    <nav class="navbar" role="navigation" aria-label="main navigation">
  <div class="container">
    <div class="navbar-brand">
      <a class="navbar-item is-size-4 has-text-weight-semibold has-text-primary" href="/">
        Volmerius
      </a>

      <a role="button" class="navbar-burger" aria-label="menu" aria-expanded="false" data-target="navbarLinks">
        <span aria-hidden="true"></span>
        <span aria-hidden="true"></span>
        <span aria-hidden="true"></span>
      </a>
    </div>

    <div id="navbarLinks" class="navbar-menu">
      <div class="navbar-start">
        <a class="navbar-item" href="/rails">
          Rails Guide
        </a>

        <a class="navbar-item" href="/essays">
          Essays
        </a>
      </div>
    </div>
  </div>
</nav>



    <section class="section">
      <div class="container">
        
<h1 class="title is-1">Caveats</h1>

<div class="content rails-page-content"><p>No design is perfect. The architecture proposed in this document provides a good
starting point for sustainable, long term development in Rails, but by no means
it gives answers to all possible cases and complications that could arise along
the way. It is crucial for developers to always keep in mind the principles of
object oriented design while adopting this architecture, such as keeping objects
small and simple, with thoughtful introduction of indirection when necessary.</p>
<p>This section exemplifies complications that might arise from the use of the
patterns here prescribed, with suggestions on how to address these limitations
when possible.</p>
<h2>Complex Actions</h2>
<p>Actions are designed to be the centerpieces of business logic, coordinating all
the steps required to process a user request. For that reason, they are the
objects with the highest tendency to become big, complex, and coupled with many
other structures. Actions are by definition aware of Inputs, Repositories,
Models, Jobs, and many other objects from the system. It won’t take too long for
Actions to lean towards accumulating nested code, conditionals, and many other
code smells.</p>
<p>Actions are such magnets for complexity because of their very nature of being
the core units of business logic. After all, the business logic layer of any app
is modified far more often than any other layer; the churn of business logic
code is incredibly high when compared to the rest of the system, and there is no
escape for that. This complexity can be minimized through refactorings and
indirection, but apps will always need to have business logic entry points where
everything is tied together.</p>
<p>In order to avoid excessive complexity in Actions, it is crucial to model these
objects atomically enough so they can be specialized to handle very particular
requests in isolation. Designing simpler Actions might impact even the routes
and controllers design. For example, instead of having one big Action that
receives many optional arguments, it is preferable to split it in different
Actions (and therefore different endpoints) for each specific case.</p>
<p>Actions can also collaborate with auxiliary objects that handle certain aspects
of business logic beyond Repositories and Jobs. Each app might require
additional objects and layers so the burden in Actions is reduced. For instance,
the specifics of crafting outgoing HTTP requests to services might be deferred
to service objects that play that role, and Actions can simply instantiate and
send messages to them.</p>
<h2>Duplication in Actions</h2>
<p>Actions might end up sharing similarities to other Actions, leading to an excess
of duplicated code in these objects. Given that by design Actions are not
allowed to interact with each other, and also given that there can only be one
Action for each request, it might get tricky to remove the repeated logic.</p>
<p>First of all, it is important to emphasize that not all duplication needs to be
removed in order to achieve a sustainable architecture. More often than not,
attempts to remove duplication lead to a poor, complex design and an overall
worse code than the previous duplicated code. Developers feel the urge to remove
every and single duplication as a deceitful instinct of fixing a possible code
smell. The truth, however, is that duplication is much easier to understand and
change than abstractions that are poorly designed. Before addressing any
duplication, the best course of action is to wait until the duplicated logic is
referenced too many times, copied at least three times over.</p>
<p>Once the duplication becomes a real concern, the code can be refactored by
extracting the repeated logic into specialized objects Actions can interact
with. A particular case is when the duplication happens around composing the
Result object. An app might introduce a new layer of Result composers for that
purpose that Actions can rely on and delegate that process to.</p>
<h2>Testing Actions</h2>
<p>The topic of testing is not covered in this document, but a word is needed
regarding testing Actions. Actions don’t need to be tested through unit tests.
Instead, these objects’ behaviours should be asserted indirectly through proper
integration test coverage.</p>
<p>Given that Actions represent an entire feature or use case, developers might be
tempted to end up writing unit tests that are actually integration tests in
disguise. For example, a unit test for the Create Article Action might end up
asserting that a Record is persisted. This test is not a unit test, since the
code in the Action is completely decoupled from the database or from Active
Record itself. Such assertions are important, but should be written as
integration or system tests.</p>
<p>In theory, unit testing for Actions needs to ensure that the Action is sending
the expected messages to its collaborator objects and that the Result returned
by the Action has the right values, and nothing more. This would likely require
mocking/stubbing libraries, so tests are performed fast by not actually making
network calls or database operations. Once again, this does not replace the need
for integration tests whatsoever, since only these end-to-end assertions can
ensure that the system as a whole is functional and the network of objects
behave properly in the real world.</p>
<p>Given that the only way to test Actions is through excessive stubbing and
mocking, and that these unit tests do not replace integration tests, writing
unit tests for Actions is an unnecessary burden. Instead, the Actions behaviours
should be asserted indirectly through proper integration test coverage.</p>
<h2>Validation Antipatterns</h2>
<p>This architecture proposes the use of validation in Input objects by including
Active Model validations. By inheriting from Active Model, Inputs can have the
same well-known validation API and seamlessly integrate with view forms.</p>
<pre class="language-ruby"><code class="language-ruby">  <span class="prism--token prism--keyword">if</span> input<span class="prism--token prism--punctuation">.</span>valid<span class="prism--token prism--operator">?</span>
    <span class="prism--token prism--variable">@article</span> <span class="prism--token prism--operator">=</span> <span class="prism--token prism--class-name">ArticleRepository</span><span class="prism--token prism--punctuation">.</span><span class="prism--token prism--keyword">new</span><span class="prism--token prism--punctuation">.</span>create<span class="prism--token prism--punctuation">(</span>input<span class="prism--token prism--punctuation">)</span>
  <span class="prism--token prism--keyword">else</span>
    failure<span class="prism--token prism--punctuation">(</span>input<span class="prism--token prism--punctuation">.</span>errors<span class="prism--token prism--punctuation">)</span>
  <span class="prism--token prism--keyword">end</span></code></pre>
<p>This approach comes with costs, however. Firstly, this choice lets Inputs
inherit the Rails antipattern of mutating objects in order to fetch validation
results. A valid object has no errors, but only until someone else asks it for
its valid state, in which it might end up populating its own errors, mutating
its own state. This is a brittle design that violates the idea of an Input
representing the user’s entries and nothing more. Worst even, this mutation
happens by calling a predicate method. Predicates, as any query method, should
simply return information about the object but not alter the state of a
subsystem.</p>
<p>Secondly, validation errors are represented as instances of Active Model Errors,
which is quite limited in its API. There are no standardized formats for
individual errors, which might negatively impact the design of meaningful
representation of validation messages, as seen in the GraphQL section.</p>
<p>Apps that face these costs might opt for not using Active Model for input
validation, but instead introduce their own Validators as collaborator objects
that Actions can invoke in order to check for the validity of Inputs. Similarly,
errors can be represented using well-defined structs with proper fields such as
messages, codes, and attribute names.</p>
<h2>Transactions</h2>
<p>Database transactions guarantee that a series of steps are performed atomically,
making possible to roll them all back in case of errors. In Rails, transactions
are defined as blocks where all their database operations are committed to the
database together in case of a successful yield, or rolled back if an error is
raised.</p>
<p>Grouping logical steps in atomic groups with transactions is part of the
business logic layer. When the app requires transactions, there is a risk for
Actions to end up coupled with Active Record once again. In order to achieve a
sustainable architecture, however, it is important to respect the design
decision to encapsulate Active Record behind Repositories in this case as well.
Additionally, transactions are excellent candidates to be extracted into more
specialized objects.</p>
<p>Back to the Blog example, let’s say we don’t want to persist a comment if the
Job that delivers the notification email fails to be enqueued. This requires
grouping the Comment creation and the email notification delivery in a
transaction.</p>
<p>The first thing we can do is to create a method in the Repository to encapsulate
Active Record:</p>
<pre class="language-ruby"><code class="language-ruby"><span class="prism--token prism--keyword">class</span> <span class="prism--token prism--class-name">CommentRepository</span>
  <span class="prism--token prism--keyword">class</span> <span class="prism--token prism--operator">&lt;&lt;</span> <span class="prism--token prism--keyword">self</span>
    <span class="prism--token prism--keyword">def</span> <span class="prism--token prism--method-definition"><span class="prism--token prism--function">transaction</span></span>
      ActiveRecord<span class="prism--token prism--double-colon prism--punctuation">::</span>Base<span class="prism--token prism--punctuation">.</span>transaction <span class="prism--token prism--punctuation">{</span> <span class="prism--token prism--keyword">yield</span><span class="prism--token prism--punctuation">(</span><span class="prism--token prism--keyword">new</span><span class="prism--token prism--punctuation">)</span> <span class="prism--token prism--punctuation">}</span>
    <span class="prism--token prism--keyword">end</span>
  <span class="prism--token prism--keyword">end</span>
<span class="prism--token prism--keyword">end</span></code></pre>
<p>We can now model our transaction as an object that executes the piece of
protected business logic that is rolled back all at once in case of errors:</p>
<pre class="language-ruby"><code class="language-ruby"><span class="prism--token prism--keyword">class</span> <span class="prism--token prism--class-name">CreateCommentTransaction</span>
  <span class="prism--token prism--keyword">def</span> <span class="prism--token prism--method-definition"><span class="prism--token prism--function">perform</span></span><span class="prism--token prism--punctuation">(</span>input<span class="prism--token prism--punctuation">)</span>
    CommentRepository<span class="prism--token prism--punctuation">.</span>transaction <span class="prism--token prism--keyword">do</span> <span class="prism--token prism--operator">|</span>repository<span class="prism--token prism--operator">|</span>
      comment <span class="prism--token prism--operator">=</span> repository<span class="prism--token prism--punctuation">.</span>create<span class="prism--token prism--punctuation">(</span>input<span class="prism--token prism--punctuation">)</span>
      NewCommentEmailJob<span class="prism--token prism--punctuation">.</span>perform_later<span class="prism--token prism--punctuation">(</span>comment<span class="prism--token prism--punctuation">.</span>id<span class="prism--token prism--punctuation">)</span>
      comment
    <span class="prism--token prism--keyword">end</span>
  <span class="prism--token prism--keyword">end</span>
<span class="prism--token prism--keyword">end</span></code></pre>
<p>The Action can now simply validate the input and perform the Transaction,
remaining decoupled from Active Record, or the transaction block itself:</p>
<pre class="language-ruby"><code class="language-ruby"><span class="prism--token prism--keyword">class</span> <span class="prism--token prism--class-name">CreateCommentAction</span> <span class="prism--token prism--operator">&lt;</span> Action
  expose <span class="prism--token prism--symbol">:comment</span>

  <span class="prism--token prism--keyword">def</span> <span class="prism--token prism--method-definition"><span class="prism--token prism--function">perform</span></span><span class="prism--token prism--punctuation">(</span>input<span class="prism--token prism--punctuation">)</span>
    <span class="prism--token prism--keyword">if</span> input<span class="prism--token prism--punctuation">.</span>valid<span class="prism--token prism--operator">?</span>
      <span class="prism--token prism--variable">@comment</span> <span class="prism--token prism--operator">=</span> <span class="prism--token prism--class-name">CreateCommentTransaction</span><span class="prism--token prism--punctuation">.</span><span class="prism--token prism--keyword">new</span><span class="prism--token prism--punctuation">.</span>perform<span class="prism--token prism--punctuation">(</span>input<span class="prism--token prism--punctuation">)</span>
    <span class="prism--token prism--keyword">else</span>
      failure<span class="prism--token prism--punctuation">(</span>input<span class="prism--token prism--punctuation">.</span>errors<span class="prism--token prism--punctuation">)</span>
    <span class="prism--token prism--keyword">end</span>
  <span class="prism--token prism--keyword">end</span>
<span class="prism--token prism--keyword">end</span></code></pre>
</div>

<nav class="pagination is-centered" role="navigation" aria-label="pagination">
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
  
    
      

      
        <a class="pagination-previous" href="/rails/extensions/">Previous: Extensions</a>
      

      

      
        <a class="pagination-next" href="/rails/final-words/">Next: Final Words</a>
      
    
  
    
  
</nav>


        <footer class="footer">
  <div class="content has-text-centered">
    <p>
      <a href="https://x.com/volmerius" target="_blank" rel="noopener" title="X">
        <span class="icon is-medium">
          <i class="fab fa-2x fa-x-twitter"></i>
        </span>
      </a>
    </p>
  </div>

  <div class="content has-text-centered is-small">
    <p>Copyright © 2025 Volmer Campos Soares</p>
  </div>
</footer>

      </div>
    </section>
  </body>
</html>
